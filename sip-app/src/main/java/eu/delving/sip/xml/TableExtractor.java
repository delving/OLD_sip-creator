/*
 * Copyright 2011, 2012 Delving BV
 *
 * Licensed under the EUPL, Version 1.0 or? as soon they
 * will be approved by the European Commission - subsequent
 * versions of the EUPL (the "Licence");
 * you may not use this work except in compliance with the
 * Licence.
 * You may obtain a copy of the Licence at:
 *
 * http://ec.europa.eu/idabc/eupl
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the Licence is
 * distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the Licence for the specific language governing
 * permissions and limitations under the Licence.
 */

package eu.delving.sip.xml;

import eu.delving.XMLToolFactory;

import javax.xml.stream.XMLEventFactory;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import java.io.FileNotFoundException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map;
import java.util.Stack;
import java.util.TreeMap;

/**
 * Create a hierarchical dump based on a profile that is initially generated by
 * introspecting the database and then adjusted to determine the contents of the dump.
 *
 * @author Gerald de Jong <gerald@delving.eu>
 */

public class TableExtractor {
    private static final String DUMP_ENVELOP_TAG = "delving-db-dump";
    private XMLOutputFactory outputFactory = XMLToolFactory.xmlOutputFactory();
    private XMLEventFactory event = XMLToolFactory.xmlEventFactory();
    private Stack<ResultSet> resultSets = new Stack<ResultSet>();
    private XMLEventWriter out;
    private Connection connection;
    private RelationalProfile profile;
    private int maxRows;

    public TableExtractor(Connection connection, RelationalProfile profile) {
        this.connection = connection;
        this.profile = profile;
    }

    public void setMaxRows(int maxRows) {
        this.maxRows = maxRows;
    }

    public void fillCaches() throws SQLException {
        for (RelationalProfile.Table table : profile.tables) {
            if (!table.cached) continue;
            table.cache = new HashMap<String, Map<String, String>>();
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(table.toQuery(null));
            while (resultSet.next()) {
                String key = null;
                Map<String, String> value = new TreeMap<String, String>();
                for (RelationalProfile.Column column : table.columns) {
                    if (column.key) key = resultSet.getString(column.name);
                    String fieldValue = getValue(column, resultSet);
                    if (fieldValue != null) value.put(column.name, fieldValue);
                }
                if (key == null) throw new RuntimeException("Table missing key column: " + table.name);
                table.cache.put(key, value);
            }
            statement.close();
        }
    }

    public void dumpTo(OutputStream outputStream) throws FileNotFoundException, UnsupportedEncodingException, XMLStreamException, SQLException {
        out = outputFactory.createXMLEventWriter(new OutputStreamWriter(outputStream, "UTF-8"));
        startDocument();
        dumpTo(profile.rootTable());
        endDocument();
    }

    private void dumpTo(RelationalProfile.Table table) throws SQLException, XMLStreamException {
        int indent = resultSets.size() + 1;
        String key = resultSets.isEmpty() ? null : resultSets.peek().getString(table.linkColumn.link.name);
        if (table.cached) {
            if (key == null) return;
            Map<String, String> result = table.cache.get(key);
            startWrapper(table.name, indent);
            for (RelationalProfile.Column column : table.columns) {
                putValue(column, result, indent + 1);
            }
            endWrapper(table.name, indent);
        }
        else {
            Statement statement = connection.createStatement();
            if (maxRows > 0) statement.setMaxRows(maxRows);
            resultSets.push(statement.executeQuery(table.toQuery(key)));
            int count = 0;
            while (resultSets.peek().next()) {
                try {
                    if (resultSets.size() == 1) {
                        Thread.sleep(1000); // todo: absurd, but worth a try
                        System.out.println("=== Record "+(++count));
                    }
                }
                catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                startWrapper(table.name, indent);
                for (RelationalProfile.Column column : table.columns) {
                    putValue(column, resultSets.peek(), indent + 1);
                }
                for (RelationalProfile.Table childTable : profile.childTables(table)) {
                    dumpTo(childTable);
                }
                endWrapper(table.name, indent);
            }
            resultSets.pop();
            statement.close();
        }
    }

    private String getValue(RelationalProfile.Column column, ResultSet resultSet) throws SQLException {
        String value = resultSet.getString(column.name); // todo: improve this if necessary
        if (value == null) return null;
        return checkEmpty(column, value);
    }

    private String getValue(RelationalProfile.Column column, Map<String, String> result) {
        String value = result.get(column.name);
        if (value == null) return null;
        return checkEmpty(column, value);
    }

    private String checkEmpty(RelationalProfile.Column column, String value) {
        value = value.trim();
        return column.isEmpty(value) ? null : value;
    }

    private void putValue(RelationalProfile.Column column, Map<String, String> result, int indent) throws XMLStreamException, SQLException {
        String value = getValue(column, result);
        if (value == null) return;
        while (indent-- > 0) out.add(event.createCharacters("   "));
        out.add(event.createStartElement("", "", column.name, null, null));
        out.add(event.createCharacters(value));
        out.add(event.createEndElement("", "", column.name));
        out.add(event.createCharacters("\n"));
    }

    private void putValue(RelationalProfile.Column column, ResultSet resultSet, int indent) throws XMLStreamException, SQLException {
        String value = getValue(column, resultSet);
        if (value == null) return;
        while (indent-- > 0) out.add(event.createCharacters("   "));
        out.add(event.createStartElement("", "", column.name, null, null));
        out.add(event.createCharacters(value));
        out.add(event.createEndElement("", "", column.name));
        out.add(event.createCharacters("\n"));
    }

    private void startWrapper(String tag, int indent) throws XMLStreamException {
        while (indent-- > 0) out.add(event.createCharacters("   "));
        out.add(event.createStartElement("", "", tag, null, null));
        out.add(event.createCharacters("\n"));
    }

    private void endWrapper(String tag, int indent) throws XMLStreamException {
        while (indent-- > 0) out.add(event.createCharacters("   "));
        out.add(event.createEndElement("", "", tag));
        out.add(event.createCharacters("\n"));
    }

    private void startDocument() throws XMLStreamException {
        out.add(event.createStartDocument());
        out.add(event.createCharacters("\n"));
        out.add(event.createStartElement("", "", DUMP_ENVELOP_TAG, null, null));
        out.add(event.createCharacters("\n"));
    }

    private void endDocument() throws XMLStreamException {
        out.add(event.createEndElement("", "", DUMP_ENVELOP_TAG));
        out.add(event.createCharacters("\n"));
        out.add(event.createEndDocument());
    }
}
